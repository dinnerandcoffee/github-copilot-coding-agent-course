# 05. Large Codebase  
큰 코드베이스에서 Copilot 안전하게 쓰기

이 강의부터는 Copilot을  
**실제 실무 환경에 가까운 조건**에서 사용하기 시작한다.

파일이 많아지고,  
수정하면 안 되는 코드가 생기며,  
실수의 비용도 커진다.

이때 필요한 것은 **더 똑똑한 Copilot**이 아니라,  
**더 안전한 사용법**이다.

---

## 이 강의의 목표

이 강의가 끝나면 다음을 할 수 있어야 한다.

- Copilot의 수정 범위를 명확히 제한한다
- 여러 파일이 있는 프로젝트에서 작업을 맡긴다
- 리팩토링과 기능 추가를 구분한다
- “건드리면 안 되는 코드”를 보호한다

---

## 왜 큰 코드베이스가 위험한가

파일이 하나일 때 Copilot은 비교적 안전하다.  
하지만 파일이 늘어나면 상황이 달라진다.

- 의도하지 않은 파일 수정
- 핵심 로직 변경
- 불필요한 구조 개편

이 문제의 원인은 대부분 동일하다.

> **Copilot이 나쁜 게 아니라,  
> 범위와 책임이 주어지지 않았다.**

---

## Step 1. 먼저 구조를 설명하게 하라

작업을 맡기기 전에,  
Copilot이 프로젝트를 어떻게 이해하고 있는지 확인한다.

~~~text
이 프로젝트의 파일 구조를 요약하고,
각 파일의 역할을 설명해줘.
~~~

### 확인 포인트
- 파일별 책임을 구분하는가?
- 중요한 파일을 인식하는가?

👉 이 단계 없이 바로 작업을 맡기면 위험하다.

---

## Step 2. 수정 가능 범위 명시하기

이제 Copilot의 행동 반경을 제한한다.

~~~text
다음 조건을 반드시 지켜줘.

- 수정 가능 파일: todo.py
- 수정 금지 파일: main.py, config.py
- 새 파일 생성 금지
~~~

이 세 줄만으로도  
사고 확률이 크게 줄어든다.

---

## Step 3. 리팩토링과 기능 추가를 구분하라

큰 코드베이스에서 가장 흔한 사고는  
**리팩토링인 줄 알았는데 기능이 바뀌는 경우**다.

리팩토링 요청은 이렇게 한다.

~~~text
다음 파일을 리팩토링해줘.

조건:
- 기능 변경 없음
- 가독성 개선만 수행
- 변경 요약 제공
~~~

기능 추가 요청은 이렇게 한다.

~~~text
다음 기능을 추가해줘.

조건:
- 기존 기능 유지
- 영향받는 파일 목록 명시
- 테스트 필요 여부 설명
~~~

👉 두 요청은 **절대 섞지 않는다.**

---

## Step 4. 바로 수정하지 말고 계획부터 받기

위험한 작업일수록  
바로 수정하게 두지 않는다.

~~~text
바로 수정하지 말고,
변경이 필요한 부분과
수정 계획을 먼저 설명해줘.
~~~

이 단계에서 대부분의 사고가 예방된다.

---

## 흔히 하는 실수

- “전반적으로 개선해줘” 같은 요청
- 리팩토링과 기능 추가를 동시에 요청
- 수정 범위 미지정

이 실수들은  
Copilot을 **폭주 상태**로 만든다.

---

## 안전 사용 체크리스트

- [ ] 구조 요약을 먼저 요청했다
- [ ] 수정 가능/금지 범위를 명시했다
- [ ] 리팩토링과 기능 요청을 구분했다
- [ ] 변경 계획을 먼저 검토했다

이 체크리스트를 통과하면  
큰 코드베이스에서도 Copilot을 쓸 수 있다.

---

## 정리

큰 코드베이스에서의 Copilot 사용은  
능력 문제가 아니라 **관리 문제**다.

> **Copilot은 통제받을 때  
> 가장 강력하다.**

---

## 다음 단계

👉 **06. Test & Debug – 테스트와 버그 수정 자동화**

이제 Copilot에게  
테스트와 디버깅까지 맡기는 단계로 간다.
